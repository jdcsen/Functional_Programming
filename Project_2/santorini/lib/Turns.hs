{-# LANGUAGE GADTs #-}

module Turns where

import SantoriniRep

-- Actions provide certain guarantees. All actions can be applied in their
-- entirety without having to worry about a win or a lose state interrupting
-- the action.
data Action where
  Place :: IPt        -> Action
  Build :: IPt        -> Action
  Move  :: IPt -> IPt -> Action
  Swap  :: IPt -> IPt -> Action
  Push  :: IPt -> IPt -> Action

-- Now that we have data structures that can be applied to boards, organize them
-- into a neat class.
class Mutator a where
  mutate :: IBoard -> a -> IBoard

instance Mutator Action where
  mutate brd _ = brd -- TODO: Implement. Simple, but we need tests first.

-- Every turn is represented by a sequence of actions. Turns and actions are
-- card-agnostic mutations that are generated by card-specific move generators.
--
-- For example, a standard turn consists of two actions: Move, and Build
-- (unless we reached a win state with the move).
newtype Turn = Turn [Action]

instance Mutator Turn where
  mutate brd (Turn turnList) = brd -- TODO: replace with 'foldl mutate brd turnList' after tests.
