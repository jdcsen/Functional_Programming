{-# LANGUAGE GADTs #-}

module Turns where

import SantoriniRep
import SantoriniLogic

-- Actions provide certain guarantees. All actions can be applied in their
-- entirety without having to worry about a win or a lose state interrupting
-- the action.

-- Note: I don't particularly like having separate Enum and GADTs. I definitely
-- want the features and cleanliness of the GADT, but I need to be able to specify
-- move type without fully constructing it. I don't currently know how to reconcile
-- these requirements.
data ActionE =
  PlaceE |
  BuildE |
  CapE   |
  MoveE  |
  SwapE  |
  PushE  deriving (Enum)

data Action where
  Place :: IPt        -> Action
  Build :: IPt        -> Action
  Cap   :: IPt        -> Action
  Move  :: IPt -> IPt -> Action
  Swap  :: IPt -> IPt -> Action
  Push  :: IPt -> IPt -> Action deriving (Eq)

-- An Agent is a single token from a player. Currently, the rules allow moves of
-- a single agent per turn.
type Agent = IPt

-- To simply order actions, assign each a priority.
toPriority :: Action -> Int
toPriority (Place _)   = 0
toPriority (Build _)   = 10
toPriority (Push _ _)  = 30
toPriority (Cap _)     = 40
toPriority (Swap _ _)  = 50
toPriority (Move _ _)  = 60

-- Order actions by priority
instance Ord Action where
  compare a b = compare (toPriority a) (toPriority b)

-- Now that we have data structures that can be applied to boards, organize them
-- into a neat class.
class Mutator a where
  mut      :: IBoard -> a -> IBoard
  mutAgent :: Agent -> a -> Agent
  mutTup   :: (Agent, IBoard) -> a -> (Agent, IBoard)

instance Mutator Action where
  -- Mutate Board
  mut brd (Place loc)  = placePlayer brd loc
  mut brd (Build loc)  = buildLvl brd loc
  mut brd (Move l1 l2) = movePlayer brd (l1, l2)
  mut brd (Swap l1 l2) = swapPlayer brd (l1, l2)
  mut brd (Push l1 l2) = pushPlayer brd (l1, l2)
  -- Cap is a little more complicated, we query height and
  -- build any remaining height.
  mut brd (Cap loc)    = capped
    where
      remHeight = gMaxTower - getHeight (getTok brd loc)
      capped = foldl buildLvl brd $ replicate remHeight loc
  -- Mutate Agents
  mutAgent lAgent (Move _ finalLoc) = finalLoc
  mutAgent lAgent (Swap _ finalLoc) = finalLoc
  mutAgent lAgent (Push _ finalLoc) = finalLoc
  -- All other actions do not mutate the agent.
  mutAgent lAgent _  = lAgent
  -- Convenience function, so we can easily chain moves with the same agent.
  mutTup (agent, brd) action = (mutAgent agent action, mut brd action)

-- Every turn is represented by a sequence of actions. Turns and actions are
-- card-agnostic mutations that are generated by card-specific move generators.
--
-- For example, a standard turn consists of two actions: Move, and Build
-- (unless we reached a win state with the move).
--
-- For the record, I had to try really, really hard not to make these moves an
-- instance of Semigroup. Associative turns seem so clean, and would allow us
-- to pass stuff like action position white and blacklists to more easily build
-- rule-compliant turns, instead of the current generate-filter approach..
newtype Turn = Turn [Action] deriving (Eq)

-- Order turns by the sum of the priority
instance Ord Turn where
  compare (Turn a) (Turn b) =
    compare (sum (map toPriority a)) (sum (map toPriority b))

instance Mutator Turn where
  mut brd (Turn turnList) = foldl mut brd turnList
  mutAgent lAgent (Turn turnList) = foldl mutAgent lAgent turnList
  mutTup (agent, brd) trn = (mutAgent agent trn, mut brd trn)

getActions :: Turn -> [Action]
getActions (Turn act) = act
