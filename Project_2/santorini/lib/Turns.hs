{-# LANGUAGE GADTs #-}

module Turns where

import SantoriniRep
import SantoriniLogic

gMaxRowPriority = 9
gMaxColPriority = 9

-- Actions provide certain guarantees. All actions can be applied in their
-- entirety without having to worry about a win or a lose state interrupting
-- the action.

-- Note: I don't particularly like having separate Enum and GADTs. I definitely
-- want the features and cleanliness of the GADT, but I need to be able to specify
-- move type without fully constructing it. I don't currently know how to reconcile
-- these requirements.
data ActionE =
  PlaceE |
  BuildE |
  CapE   |
  MoveE  |
  SwapE  |
  PushE  deriving (Enum)

data Action where
  Place :: IPt        -> Action
  Build :: IPt        -> Action
  Cap   :: IPt        -> Action
  Move  :: IPt -> IPt -> Action
  Swap  :: IPt -> IPt -> Action
  Push  :: IPt -> IPt -> Action deriving (Eq, Show)

-- An Agent is a single token from a player. Currently, the rules allow moves of
-- a single agent per turn.
type Agent = IPt

-- Given an IBoard, and an action that's just been applied to said
-- IBoard, returns the agent if it can be determined.
getAgent :: IBoard -> Action -> Maybe Agent
-- Agent can't be derived from Build or Cap, but we don't win
-- through those anyway.
getAgent brd (Build _)   = Nothing
getAgent brd (Cap _)     = Nothing
getAgent brd (Place pt)  = Just pt
getAgent brd (Move _ pt) = Just pt
getAgent brd (Swap _ pt) = Just pt
getAgent brd (Push _ pt) = Just pt


-- To simply order actions, assign each a priority.
-- Priorities are unique and deterministic. These form a rough priority, mostly
-- just to build TurnSets to be later re-prioritized by AI-specific rating functions.
--

-- Include coordinates in priority function, so moves of the same type aren't
-- considered equal.
-- Point priority ranges from 0 to 99. These priorities are entirely arbitrary,
-- but following would favor solutions in the bottom left of the board.
ptPriority :: IPt -> Int
ptPriority (IPt row col)
  | row < gMaxRowPriority && col < gMaxColPriority = (10 * row) + col
  | otherwise = error "You called ptPriority with row/col greater than the expected ranges"

-- Stacks two point priorities to ensure that the combined two point priority is
-- one-to-one in priority space. Two point priorities range from 0 to 9,999
pt2Priority :: IPt -> IPt -> Int
pt2Priority p1 p2 =
  (100 * ptPriority p1) + ptPriority p2

toPriority :: Action -> Int
toPriority (Place p1)   = 0    + ptPriority p1
-- 100 Element single point priority space.
toPriority (Build p1)   = 100  + ptPriority p1
-- 100 Element single point priority space.
toPriority (Cap p1)     = 200  + ptPriority p1
-- 100 Element single point priority space.
toPriority (Push p1 p2) = 300  + pt2Priority p1 p2
-- 1000 Element double point priority space.
toPriority (Swap p1 p2) = 1300 + pt2Priority p1 p2
-- 1000 Element double point priority space.
toPriority (Move p1 p2) = 2300 + pt2Priority p1 p2

-- Order actions by priority
instance Ord Action where
  compare a b = compare (toPriority a) (toPriority b)

-- Now that we have data structures that can be applied to boards, organize them
-- into a neat class.
class Mutator a where
  mut      :: IBoard -> a -> IBoard
  mutAgent :: Agent -> a -> Agent
  mutTup   :: (Agent, IBoard) -> a -> (Agent, IBoard)

instance Mutator Action where
  -- Mutate Board
  mut brd (Place loc)  = placePlayer brd loc
  mut brd (Build loc)  = buildLvl brd loc
  mut brd (Move l1 l2) = movePlayer brd (l1, l2)
  mut brd (Swap l1 l2) = swapPlayer brd (l1, l2)
  mut brd (Push l1 l2) = pushPlayer brd (l1, l2)
  -- Cap is a little more complicated, we query height and
  -- build any remaining height.
  mut brd (Cap loc)    = capped
    where
      remHeight = (gMaxTower - getHeight (getTok brd loc)) + 1
      capped = foldl buildLvl brd $ replicate remHeight loc
  -- Mutate Agents
  mutAgent lAgent (Move _ finalLoc) = finalLoc
  mutAgent lAgent (Swap _ finalLoc) = finalLoc
  mutAgent lAgent (Push _ finalLoc) = finalLoc
  -- All other actions do not mutate the agent.
  mutAgent lAgent _  = lAgent
  -- Convenience function, so we can easily chain moves with the same agent.
  mutTup (agent, brd) action = (mutAgent agent action, mut brd action)

-- Every turn is represented by a sequence of actions. Turns and actions are
-- card-agnostic mutations that are generated by card-specific move generators.
--
-- For example, a standard turn consists of two actions: Move, and Build
-- (unless we reached a win state with the move).
--
-- For the record, I had to try really, really hard not to make these moves an
-- instance of Semigroup. Associative turns seem so clean, and would allow us
-- to pass stuff like action position white and blacklists to more easily build
-- rule-compliant turns, instead of the current generate-filter approach..
newtype Turn = Turn [Action] deriving (Eq, Show)

-- Order turns by the sum of the priority
instance Ord Turn where
  compare (Turn a) (Turn b) =
    compare (sum (map toPriority a)) (sum (map toPriority b))

instance Mutator Turn where
  mut brd (Turn turnList) = foldl mut brd turnList
  mutAgent lAgent (Turn turnList) = foldl mutAgent lAgent turnList
  mutTup (agent, brd) trn = (mutAgent agent trn, mut brd trn)

getActions :: Turn -> [Action]
getActions (Turn act) = act
