{-# LANGUAGE GADTs #-}

module Turns where

import SantoriniRep
import SantoriniLogic

-- Actions provide certain guarantees. All actions can be applied in their
-- entirety without having to worry about a win or a lose state interrupting
-- the action.
data Action where
  Place :: IPt        -> Action
  Build :: IPt        -> Action
  Move  :: IPt -> IPt -> Action
  Swap  :: IPt -> IPt -> Action
  Push  :: IPt -> IPt -> Action deriving (Eq)

-- To simply order actions, assign each a priority.
toPriority :: Action -> Int
toPriority (Place _)   = 0
toPriority (Build _)   = 10
toPriority (Push _ _)  = 30
toPriority (Swap _ _)  = 40
toPriority (Move _ _)  = 50

-- Order actions by priority
instance Ord Action where
  compare a b = compare (toPriority a) (toPriority b)

-- Now that we have data structures that can be applied to boards, organize them
-- into a neat class.
class Mutator a where
  mutate :: IBoard -> a -> IBoard

instance Mutator Action where
  mutate brd (Place loc)  = placePlayer brd loc
  mutate brd (Build loc)  = buildLvl brd loc
  mutate brd (Move l1 l2) = movePlayer brd (l1, l2)
  mutate brd (Swap l1 l2) = swapPlayer brd (l1, l2)
  mutate brd (Push l1 l2) = pushPlayer brd (l1, l2)

-- Every turn is represented by a sequence of actions. Turns and actions are
-- card-agnostic mutations that are generated by card-specific move generators.
--
-- For example, a standard turn consists of two actions: Move, and Build
-- (unless we reached a win state with the move).
newtype Turn = Turn [Action] deriving (Eq)

-- Order turns by the sum of the priority
instance Ord Turn where
  compare (Turn a) (Turn b) =
    compare (sum (map toPriority a)) (sum (map toPriority b))

instance Mutator Turn where
  mutate brd (Turn turnList) = foldl mutate brd turnList
