{-# LANGUAGE GADTs #-}

module Turns where

import SantoriniRep
import SantoriniLogic

-- Actions provide certain guarantees. All actions can be applied in their
-- entirety without having to worry about a win or a lose state interrupting
-- the action.
data Action where
  Place :: IPt        -> Action
  Build :: IPt        -> Action
  Move  :: IPt -> IPt -> Action
  Swap  :: IPt -> IPt -> Action
  Push  :: IPt -> IPt -> Action

-- Now that we have data structures that can be applied to boards, organize them
-- into a neat class.
class Mutator a where
  mutate :: IBoard -> a -> IBoard

instance Mutator Action where
  mutate brd (Place loc)  = placePlayer brd loc
  mutate brd (Build loc)  = buildLvl brd loc
  mutate brd (Move l1 l2) = movePlayer brd (l1, l2)
  mutate brd (Swap l1 l2) = swapPlayer brd (l1, l2)
  mutate brd (Push l1 l2) = pushPlayer brd (l1, l2)

-- Every turn is represented by a sequence of actions. Turns and actions are
-- card-agnostic mutations that are generated by card-specific move generators.
--
-- For example, a standard turn consists of two actions: Move, and Build
-- (unless we reached a win state with the move).
newtype Turn = Turn [Action]

instance Mutator Turn where
  mutate brd (Turn turnList) = foldl mutate brd turnList
